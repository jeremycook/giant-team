using Namotion.Reflection;
using System.Reflection;
using System.Text;
using static System.Console;

bool preview = args.Contains("--preview");

switch (args.FirstOrDefault())
{
    case "typescript":
        TypeScript(preview);
        break;
    default:
        WriteLine(Path.GetFileName(Environment.ProcessPath) + " [action] [--option]*");
        WriteLine();
        WriteLine("Actions:");
        WriteLine("typescript   Write TypeScript type files based on .NET types");
        WriteLine();
        WriteLine("Options:");
        WriteLine("--preview    Preview the output without modifying anything");
        WriteLine();
        break;
}

// Generate TypeScript files
static void TypeScript(bool preview)
{
    // Search up the path for the solution directory
    var solutionDirectory = new DirectoryInfo(Environment.CurrentDirectory);
    while (solutionDirectory is not null && solutionDirectory.EnumerateFiles("GiantTeam.sln").Count() != 1)
    {
        solutionDirectory = solutionDirectory.Parent;
    }
    if (solutionDirectory is null)
    {
        throw new InvalidOperationException("Solution directory not found.");
    }

    string inFolder = Path.GetFullPath("./WebApp/bin/Debug/net6.0/", solutionDirectory.FullName);
    string outFolder = Path.GetFullPath("./SolidUI/src/types/", solutionDirectory.FullName);

    var inFiles = Directory
        .EnumerateFiles(inFolder, "*.dll")
        .OrderBy(f => f);

    var solutionAssemblies = new List<Assembly>();
    foreach (var file in inFiles)
    {
        var filename = Path.GetFileName(file);
        if (filename.StartsWith("GiantTeam.") ||
            filename.StartsWith("WebApp."))
        {
            var assembly = Assembly.LoadFrom(file);
            solutionAssemblies.Add(assembly);
        }
    }

    const string tab = "    ";

    foreach (var assembly in solutionAssemblies)
    {
        var sb = new StringBuilder();

        var types = assembly
        .ExportedTypes
        .Where(t =>
            t.Name.EndsWith("Input") ||
            t.Name.EndsWith("Output") ||
            t.Name.EndsWith("Status")
        );

        foreach (var type in types)
        {
            if (type.IsEnum)
            {
                sb.Append($"export enum {type.Name} {{\n");
                foreach (var (field, value) in Enum.GetNames(type).Zip(Enum.GetValues(type).Cast<int>()))
                {
                    sb.Append(tab);
                    sb.Append(field);
                    sb.Append(" = ");
                    sb.Append(value);
                    sb.Append(",\n");
                }
                sb.Append("}\n\n");
            }
            else
            {
                sb.Append($"export interface {type.Name} {{\n");
                foreach (var prop in type.GetProperties())
                {
                    var contextualProperty = prop.ToContextualProperty();
                    bool udt = solutionAssemblies.Contains(prop.PropertyType.Assembly);
                    bool nullable = contextualProperty.Nullability == Nullability.Nullable;

                    sb.Append(tab);
                    sb.Append(prop.Name[0..1].ToLower() + prop.Name[1..]);
                    if (nullable) sb.Append("?");
                    sb.Append(": ");
                    sb.Append(udt ? prop.PropertyType.Name : prop.PropertyType.Name.ToLower());
                    sb.Append(";\n");

                }
                sb.Append("}\n\n");
            }
        }

        string outFile = Path.Combine(outFolder, assembly.GetName().Name + ".ts");
        if (preview)
        {
            WriteLine("// " + outFile);
            WriteLine(sb.ToString());
        }
        else
        {
            if (sb.Length <= 0)
            {
                File.Delete(outFile);
            }
            else
            {
                string content =
                    "// DO NOT MODIFY!\n" +
                    "// Generated by " + typeof(Program).Assembly.GetName().Name + "\n\n" +
                    sb.ToString().TrimEnd('\n');

                File.WriteAllText(outFile, content);
            }
        }
    }
}
