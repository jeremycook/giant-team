using Namotion.Reflection;
using System.Reflection;
using System.Text;
using static System.Console;

bool preview = args.Contains("--preview");

switch (args.FirstOrDefault())
{
    case "typescript":
        TypeScript(preview);
        break;
    default:
        WriteLine(Path.GetFileName(Environment.ProcessPath) + " [tool] [--option]*");
        WriteLine();
        WriteLine("Tools:");
        WriteLine("typescript   Write TypeScript type files based on .NET types");
        WriteLine();
        WriteLine("Options:");
        WriteLine("--preview    Preview the output without modifying anything");
        WriteLine();
        break;
}

static void TypeScript(bool preview)
{
    // Search up the path for the solution directory
    var solutionDirectory = new DirectoryInfo(Environment.CurrentDirectory);
    while (solutionDirectory is not null && solutionDirectory.EnumerateFiles("GiantTeam.sln").Count() != 1)
    {
        solutionDirectory = solutionDirectory.Parent;
    }
    if (solutionDirectory is null)
    {
        throw new InvalidOperationException("The solution directory could not be determined.");
    }

    string inFolder = Path.GetFullPath(
        Path.GetDirectoryName(Environment.ProcessPath) ??
        throw new InvalidOperationException("The input directory could not be determined.")
    , solutionDirectory.FullName);

    string outFolder = Path.GetFullPath("./SolidUI/src/types/", solutionDirectory.FullName);

    var inFiles = Directory
        .EnumerateFiles(inFolder, "*.dll")
        .OrderBy(f => f);

    var solutionAssemblies = new List<Assembly>();
    foreach (var file in inFiles)
    {
        var filename = Path.GetFileName(file);
        if (filename.StartsWith("GiantTeam."))
        {
            var assembly = Assembly.LoadFrom(file);
            solutionAssemblies.Add(assembly);
        }
    }

    const string tab = "    ";

    foreach (var assembly in solutionAssemblies)
    {
        var sb = new StringBuilder();

        var types = assembly
        .ExportedTypes
        .Where(t =>
            t.Name.EndsWith("Input") ||
            t.Name.EndsWith("Output") ||
            t.Name.EndsWith("Status")
        );

        foreach (var type in types)
        {
            if (type.IsEnum)
            {
                sb.Append($"export enum {type.Name} {{\n");
                foreach (var (field, value) in Enum.GetNames(type).Zip(Enum.GetValues(type).Cast<int>()))
                {
                    sb.Append(tab);
                    sb.Append(field);
                    sb.Append(" = ");
                    sb.Append(value);
                    sb.Append(",\n");
                }
                sb.Append("}\n\n");
            }
            else
            {
                sb.Append($"export interface {type.Name} {{\n");
                foreach (var prop in type.GetProperties())
                {
                    var contextualProperty = prop.ToContextualProperty();
                    bool udt = solutionAssemblies.Contains(prop.PropertyType.Assembly);
                    bool nullable = contextualProperty.Nullability == Nullability.Nullable;

                    sb.Append(tab);
                    sb.Append(prop.Name[0..1].ToLower() + prop.Name[1..]);
                    if (nullable) sb.Append("?");
                    sb.Append(": ");
                    sb.Append(udt ? prop.PropertyType.Name : prop.PropertyType.Name.ToLower());
                    sb.Append(";\n");

                }
                sb.Append("}\n\n");
            }
        }

        string outFile = Path.Combine(outFolder, assembly.GetName().Name + ".ts");
        if (sb.Length <= 0)
        {
            if (File.Exists(outFile))
            {
                if (preview)
                {
                    WriteLine("DEL: " + outFile);
                }
                else
                {
                    File.Delete(outFile);
                    WriteLine("DEL: " + outFile);
                }
            }
        }
        else
        {
            string content =
                "// DO NOT MODIFY!\n" +
                "// Generated by " + typeof(Program).Assembly.GetName().Name + "\n\n" +
                sb.ToString().TrimEnd('\n');

            if (File.Exists(outFile))
            {
                if (File.ReadAllText(outFile) != content)
                {
                    if (preview)
                    {
                        WriteLine("MOD: " + outFile);
                        WriteLine(outFile);
                    }
                    else
                    {
                        File.WriteAllText(outFile, content);
                        WriteLine("MOD: " + outFile);
                    }
                }
            }
            else
            {
                if (preview)
                {
                    WriteLine("ADD: " + outFile);
                    WriteLine(outFile);
                }
                else
                {
                    File.WriteAllText(outFile, content);
                    WriteLine("ADD: " + outFile);
                }
            }
        }
    }
}
